#!/usr/bin/perl

#-------------------------------------------------------------------------------
#                                                                               
#   Name:       make.qt.config                                                  
#                                                                               
#   Classification: UNCLASSIFIED, OPEN SOURCE                                   
#                                                                               
#   Purpose:    Make the configuration file for creating Qt Makefiles.          
#               This procedure should be run after you create a new main        
#               program.
#                                                       
#   -dpath          Search the path for SOURCES and HEADER; pass to compiler.   
#   -Dmacro=42      Pass qualifier to compiler.                                 
#   -fflag          Add the given flag to the CXXFLAGS                          
#   -Ipath          Search the path for HEADERS; pass to compiler.              
#   -lname          Pass qualifier to linker.                                   
#   -Lpath          Pass qualifier to linker.                                   
#   -mpath/file     Path to main source file.                                   
#   -qpath          qrc resource file                                           
#   -TDpath         Path to target dependency 
#   --threads=      Number of threads available to use. 
#
#                                                                                
#   @version    2016-04-04  DHF     File creation.  
#   @version    2020-10-19  PN      Combined make.qt.config and makepro. Added
#                                   --threads=.                            
#
#   @TODO: Try using print <<EOF instead of quotes inside functions.                                                                               
#-------------------------------------------------------------------------------

use strict;
use warnings;
use File::Basename;
use threads;
use threads::shared;
use Thread::Queue;

my @cxx_flags;
my @directories;
my @inc_pathes;
my @library;
my @macros;
my @targetdeps;
my @main_files;
my @src_files;
my @hdr_files;
my @img_files;
my @qrc_files;
my @qmake_command;

my %config;
my %qt;
my %main_files_path;

my $version = "V 1.0.0 ";   # $version is same length as the value held.        
my @date = localtime;
my $date_time = sprintf("%04d-%02d-%02d", $date[5]+1900, $date[4]+1, $date[3]);
my $qmake = "qmake-qt4";

my $file_queue = Thread::Queue->new();
my $thread_count = `nproc`;
my @threads;
my %include;

my $qrc_file = "../common/qt.qrc";

#-------------------------------------------------------------------------------
#   Thread related variables:  either used by multiple threads or holds threads.
#-------------------------------------------------------------------------------
share(%include);
share(@main_files);
share(%main_files_path);
share(@qmake_command);
share(@src_files);
share(@hdr_files);
share(@qrc_files);
share(@img_files);

for my $a (@ARGV)
{
    if ($a =~ /^-c(.*)/) {
        $config{$1} = 1;

    } elsif ($a =~ /^-d(.*)/) {
        push(@directories, $1);
        &directory($1);

    } elsif ($a =~ /^-D(.*)/) {
        push(@macros, $1);

    } elsif ($a =~ /^-f(.*)/) {
        push(@cxx_flags, $1);
        
    } elsif ($a =~ /^-I(.*)/) {
        push(@inc_pathes, $1);

    } elsif ($a =~ /^-l(.*)/) {
        push(@library, $1);

    } elsif ($a =~ /^-L/) {
        push(@library, $a);

    } elsif ($a =~ /^--qmake=(.*)/) {
        $qmake = $1;

    } elsif ($a =~ /^-qt(.*)/) {
        $qt{$1} = 1;
        
    } elsif ($a =~ /^-q(.*)/) {
        $qrc_file = $1;

    } elsif ($a =~ /^-TD(.*)/) {
        push(@targetdeps, $1);

    } elsif ($a =~ /^--threads=(.*)/) {
        $thread_count = $1;

    }
}

$config{"qt"} = 1;
$config{"thread"} = 1;
$config{"stl"} = 1;
$config{"largefile"} = 1;
$config{"warn_off"} = 1;

if($^O ne 'darwin') {
    $config{"x11"} = 1;
}

if ($#directories == 0) {
    push(@directories, "../common");
}

open (BUILD, ">build") or die "Unable to open build\n$!\n";
print BUILD <<EOF;
#!/bin/bash

#-------------------------------------------------------------------------------
#   Name:           build                                                       
#                                                                               
#   Purpose:        Call each of the Makefiles generated by the latest          
#                   execution of ./makeconfig and ./configure.sh.               
#                                                                               
#   Note:           This file is automatically generated by the make.qt.config  
#                   tool.  You should [probably] not modify this file by hand.  
#                                                                               
#   Version:                                                                    
#       $date_time    MQC       Generated by make.qt.config $version            
#                                                                               
#-------------------------------------------------------------------------------

EOF

&print_build("clear && clear ");

open(QRC, ">${qrc_file}") or die "unable to open ${qrc_file}\n$!\n";
print QRC "<!DOCTYPE RCC><RCC version=\"1.0\">\n";
print QRC "  <qresource>\n";

# foreach my $dir (@directories)
# {
#     &process_dir($dir);
# }

for (my $i = 0; $i < $thread_count; ++$i)
{
    $file_queue->enqueue(undef);
    $threads[$i] = threads->create(\&process_file_queue, $i);
}

for (my $t = 0; $t < $thread_count; ++$t)
{
    $threads[$t]->join();
}

print QRC "  </qresource>\n";
print QRC "</RCC>\n";
close QRC;

print BUILD "\n";

close BUILD;

&print_pro_file();

foreach my $command(@qmake_command) {
    system($command);

}


#-------------------------------------------------------------------------------
#brief:  Walk the given directory looking for files to parse.                    
#-------------------------------------------------------------------------------
sub directory
{
    my ($dir) = @_;

    opendir(DIR, $dir) or die "Unable to open directory ${dir}\n$!\n";
    my @files = readdir(DIR);
    closedir(DIR);

    foreach my $f (@files)
    {
        my $full = $dir . "/" . $f;
        if ($f eq "." or $f eq "..") {
            #-------------------------------------------------------------------
            #   Ignore this and parent directory and -s<directories>            
            #-------------------------------------------------------------------

        } elsif (opendir(DIR, $full)) {
            closedir(DIR);
            #-------------------------------------------------------------------
            #   Ignore sub-directories. Directories provided by configure.sh          
            #-------------------------------------------------------------------

        } else {
            &queue($full);

        }
    }
}

#-------------------------------------------------------------------------------
#@brief: Add the given file to the file-queue if it hasn't already been added.   
#-------------------------------------------------------------------------------
sub queue
{
    my ($file) = @_;

    lock(%include);
    if (!defined($include{$file})) {
        $include{$file} = "";
        $file_queue->enqueue($file);
    }
}
    
#-------------------------------------------------------------------------------
#@brief: Go through each file in $file_queue and populate lists based on source
#        files, header files, images, and modules.
#-------------------------------------------------------------------------------
sub process_file_queue
{
    my ($thread_number) = @_;
    my $file_path;

    while (defined($file_path = $file_queue->dequeue_timed(2))) {
        my $file = basename($file_path);

        if ($file =~ /(.*)\.c$/i or $file =~ /(.*)\.cpp$/i or $file =~ /(.*)\.cc/i) {
            my $test = system("grep --silent \"int main\" \"${file_path}\"");
            if ($test == 0) {
                lock(@main_files);
                push(@main_files, $1);
                $main_files_path{$1} = $file_path;
                print "main program: ${file}\n";
                lock(@qmake_command);
                push(@qmake_command, "${qmake} -o Makefile-$1 $1.pro\n\n");
                &print_build("&& \\\n make -j8 -f Makefile-$1");

            } else {
                lock(@src_files);
                push(@src_files, $file_path);
            }

            &search_file($file_path);

        } elsif ($file =~ /\.h$/i or $file =~ /\.hpp$/i or $file =~ /\.hh/i) {
            lock(@hdr_files);
            push(@hdr_files, $file_path);

            &search_file($file_path);

        } elsif ($file =~ /\.qrc$/) {
            lock(@qrc_files);
            push(@qrc_files, $file_path);

        } elsif (
            $file =~ /\.gif$/
         or $file =~ /.png$/ 
         or $file =~ /.jpg$/ 
         or $file =~ /.ico$/
         or $file =~ /.svg$/
         or $file =~ /.svgz$/
         or $file =~ /.tgz$/
         or $file =~ /.css$/
         or $file =~ /.js$/
         or $file =~ /.htm$/
         or $file =~ /.html$/
        ) {
            lock(@img_files);
            push(@img_files, $file_path);
        }

    }
}

#-------------------------------------------------------------------------------
#@brief: Populate the pro file to be used with qmake.  
#-------------------------------------------------------------------------------
sub print_pro_file
{
    foreach my $file (@main_files)
    {
        open(PRO, ">${file}.pro") or die "unable to open ${file}\n$!\n";
        print PRO "
        ########################################################################
        #   qmake project file built on $date_time                                 
        #   Generated by makepro (v. 0.1.0) on $date_time                           
        #   Command Line:                                                               
        ";
        print PRO "#\n";

        foreach my $a (@ARGV) {
            printf PRO ("        #   %-70s\n", $a);
        }

        print PRO "
        ########################################################################   
        \n";


        foreach my $key (sort(keys(%config))) {
            print PRO "CONFIG          += " . $key . "\n";
        }
        print PRO "\n";

        foreach my $key (sort(keys(%qt))) {
            print PRO "QT              += " . $key . "\n";
        }
        print PRO "\n";

        foreach my $flag (@cxx_flags) {
            print PRO "QMAKE_CXXFLAGS  += " . $flag . "\n";
        }
        print PRO "\n";

        foreach my $path (@inc_pathes) {
            print PRO "INCLUDEPATH     += " . $path . "\n";
        }
        print PRO "\n";

        foreach my $lib (@library) {
            print PRO "LIBS            += " . $lib . "\n";
        }
        print PRO "\n";

        print PRO "DESTDIR         =   bin\n";
        print PRO "OBJECTS_DIR     =   obj\n";
        print PRO "MOC_DIR         =   moc\n";
        print PRO "\n";

        foreach my $target (@targetdeps) {
            print PRO "PRE_TARGETDEPS  += " . $target. "\n";
        }
        print PRO "\n";

        foreach my $header (@hdr_files) {
            print PRO "HEADERS         += " . $header. "\n";
        }
        print PRO "\n";

        print PRO "SOURCES         += " . $main_files_path{$file} . "\n";

        print PRO "\n";

        foreach my $source (@src_files) {
            print PRO "SOURCES         += " . $source . "\n";
        }
        print PRO "\n";

        foreach my $qrc (@qrc_files) {
            print PRO "RESOURCES       += " . $qrc . "\n";
        }
        print PRO "\n";

        close PRO;
    }
}

sub print_build
{
    my ($line) = @_;
    printf BUILD ("%-76s", $line);
}


#-------------------------------------------------------------------------------
#brief: Search file for QT modules.
#-------------------------------------------------------------------------------
sub search_file
{
    my ($d) = @_;

    &qt_search("core",   "Q_OBJECT",$d);
    &qt_search("gui",    "QWidget", $d);
    &qt_search("network","QNet",    $d);
    &qt_search("sql",    "QSql",    $d);
    &qt_search("svg",    "QSvg",    $d);
    &qt_search("webkit", "QWeb",    $d);
    &qt_search("webkitwidgets", "QWeb",    $d);
    &qt_search("xml",    "QXml",    $d);

}

#-------------------------------------------------------------------------------
#brief: Search file given module argument.
#-------------------------------------------------------------------------------
sub qt_search
{
    my ($module, $string, $file) = @_;

    if (!defined($qt{$module})) {
        my $test = system("grep --silent \"${string}\"  \"${file}\"");
        if ($test == 0) {
            $qt{$module} = 1;
        }
    }
}