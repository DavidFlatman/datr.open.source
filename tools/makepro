#!/usr/bin/perl -w

#-------------------------------------------------------------------------------
# @file makepro                                                                 
#                                                                               
# @par  Classification:  UNCLASSIFIED, OPEN SOURCE                              
#                                                                               
# @brief    Given a main application (-m) and a directory full of code, makepro 
#           creates a Qt project file that can be processed with qmake-qt4 or   
#           qmake-qt5.                                                          
#                                                                               
# @todo     Currently this program needs to be executed for each main routine   
#           in the directory structure.  It should be configured more along the 
#           lines of "depends" in order to have a single execution create the   
#           project file for all of the mains -- and for a link library.        
#                                                                               
#           Doing so should reduce the amount of time required by makepro and   
#           reduce the amount of time required to build the projects.           
#                                                                               
#                                                                               
#   -dpath          Search the path for SOURCES and HEADER; pass to compiler.   
#   -Dmacro=42      Pass qualifier to compiler.                                 
#   -fflag          Add the given flag to the CXXFLAGS                          
#   -Ipath          Search the path for HEADERS; pass to compiler.              
#   -lname          Pass qualifier to linker.                                   
#   -Lpath          Pass qualifier to linker.                                   
#   -mpath/file     Path to main source file.                                   
#   -qpath          qrc resource file                                           
#   -TDpath         Path to target dependency 
#   --threads=      Number of threads available to use.                                  
#   
#   version 2020-10-15  PN      Added --threads= and multi-threading.                                                                            
#   version 2012-01-26  DHF     Added -TD                                       
#                               Add comment header to output                    
#
#   version 2020-03-05  DHF     Added -qt option                                
#                                                                               
#   version 2020-09-23  MNT     Made the X11 flag OS dependant
#-------------------------------------------------------------------------------

use POSIX qw{strftime};
use threads;
use threads::shared;
use Thread::Queue;

local @inc_pathes;
local @src_pathes;

local @cxx_flags;
local @hdr_files;
local @main_files;
local @src_files;
local @img_files;

local @library;
local @macros;

local %config;
local %qt;
local $qrc_file = "../common/lib_qt.qrc";
local @qrc_files;
local @targetdeps;

local $main;

local $file_queue  = Thread::Queue->new();
local $thread_count = `nproc`;

share(@main_files);
share(@src_pathes);
share(@inc_pathes);
share(@hdr_files);
share(@src_files);
share(@library);

for my $a (@ARGV)
{
    if ($a =~ /^-c(.*)/) {
        $config{$1} = 1;
    } elsif ($a =~ /^-d(.*)/) {
        push(@src_pathes, $1);
        push(@inc_pathes, $1);
        &directory($1);

    } elsif ($a =~ /^-D/) {
        push(@macros, $a);

    } elsif ($a =~ /^-f(.*)/) {
        push(@cxx_flags, $1);
        
    } elsif ($a =~ /^-I(.*)/) {
        push(@inc_pathes, $1);

    } elsif ($a =~ /^-l(.*)/) {
        push(@library, $1);

#    } elsif ($a =~ /^-L/) {
#        push(@library, $a);

    } elsif ($a =~ /^-m(.*)/) {
        $main = $1;

    } elsif ($a =~ /^-qt(.*)/) {
        $qt{$1} = 1;

    } elsif ($a =~ /^-q(.*)/) {
        $qrc_file = $1;

    } elsif ($a =~ /^-TD(.*)/) {
        push(@targetdeps, $1);

    } elsif ($a =~ /^--threads=(.*)/) {
        $thread_count = $1;

    }
}

for (my $i = 0; $i < $thread_count; ++$i)
{
    $file_queue->enqueue(undef);
    $threads[$t] = threads->create(\&process_src_path, $i);
}

$config{"qt"} = 1;
$config{"thread"} = 1;
$config{"stl"} = 1;
$config{"largefile"} = 1;
$config{"warn_off"} = 1;

if($^O ne 'darwin') {
    $config{"x11"} = 1;
}

open(QRC, ">${qrc_file}") or die "unable to open ${qrc_file}\n$!\n";
close(QRC);

# foreach my $path (@src_pathes) {
#     &process_src_path($path);
# }

open(QRC, ">${qrc_file}") or die "unable to open ${qrc_file}\n$!\n";
print QRC "<!DOCTYPE RCC><RCC version=\"1.0\">\n";
print QRC "  <qresource>\n";
foreach my $q (@img_files) {
    print QRC "    <file>" . $q . "</file>\n";
}
print QRC "  </qresource>\n";
print QRC "</RCC>\n";
close(QRC);

my $todaysdate = strftime("%Y-%m-%d", localtime);
print <<EOF;
################################################################################
#   qmake project file built on $todaysdate                                     
#   Generated by makepro (v. 0.1.0) on $todaysdate                              
#   Command Line:                                                               
EOF

for my $a (@ARGV) {
    printf "#      %-72s\n", $a;
}
print <<EOF;
################################################################################
EOF


foreach my $key (sort(keys(%config))) {
    print "CONFIG          += " . $key . "\n";
}
print "\n";

foreach my $key (sort(keys(%qt))) {
    print "QT              += " . $key . "\n";
}
print "\n";

foreach my $flag (@cxx_flags) {
    print "QMAKE_CXXFLAGS  += " . $flag . "\n";
}
print "\n";

foreach my $path (@inc_pathes) {
    print "INCLUDEPATH     += " . $path . "\n";
}
print "\n";

foreach my $lib (@library) {
    print "LIBS            += " . $lib . "\n";
}
print "\n";

print "DESTDIR         =   bin\n";
print "OBJECTS_DIR     =   obj\n";
print "MOC_DIR         =   moc\n";
print "\n";

foreach my $file (@targetdeps) {
    print "PRE_TARGETDEPS  += " . $file. "\n";
}
print "\n";

foreach my $file (@hdr_files) {
    print "HEADERS         += " . $file. "\n";
}
print "\n";

if (defined($main)) {
    print "SOURCES         += " . $main . "\n";
}
foreach my $file (@src_files) {
    print "SOURCES         += " . $file . "\n";
}
print "\n";

foreach $file (@qrc_files) {
    print "RESOURCES       += " . $file . "\n";
}
print "\n";



#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
sub process_src_path
{

        #  elsif ($f =~ /\.c$/i or $f =~ /\.cpp$/i or $f =~ /\.cc/i) 
        #     my $test = system("grep --silent \"int main\" \"${d}\"");
        #     if ($test == 0) {
        #         push(@main_files, $d);
        #      else 
        #         push(@src_files, $d);
        #     

            &search_file($d);



} # sub process_src_path #


#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
sub search_file
{
    my ($d) = @_;

    &qt_search("core",   "Q_OBJECT",$d);
    &qt_search("gui",    "QWidget", $d);
    &qt_search("network","QNet",    $d);
    &qt_search("sql",    "QSql",    $d);
    &qt_search("svg",    "QSvg",    $d);
    &qt_search("webkit", "QWeb",    $d);
    &qt_search("webkitwidgets", "QWeb",    $d);
    &qt_search("xml",    "QXml",    $d);

}

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
sub qt_search
{
    my ($module, $string, $file) = @_;

    if (!defined($qt{$module})) {
        $test = system("grep --silent \"${string}\"  \"${file}\"");
        if ($test == 0) {
            $qt{$module} = 1;
        }
    }
}

#-------------------------------------------------------------------------------
#@brief  Search through given directory for files to parse. Function pulled from
#        depends script and adapted for makepro.                   
#-------------------------------------------------------------------------------
sub directory
{
    my ($dir) = @_;

    opendir(DIR, $dir) or die "Unable to open directory ${dir}\n$!\n";
    my @files = readdir(DIR);
    closedir(DIR);

    foreach my $f (@files)
    {
        my $full = $dir . "/" . $f;
        if ($f eq "." or $f eq ".." or defined($skip{$f})) {
            #-------------------------------------------------------------------
            #   Ignore this and parent directory and -s<directories>            
            #-------------------------------------------------------------------

        } elsif ($f =~ /\.c$/i or $f =~ /\.cpp$/i or $f =~ /\.cc/i) {

            push(@src_files, $full);
            &queue($full);

        } elsif ($f =~ /\.h$/i or $f =~ /\.hpp$/i or $f =~ /\.hh/i) {

            push(@hdr_files, $full);
            &queue($full);

        } elsif ($f =~ /\.qrc$/) {
            push(@qrc_files, $full);

        } elsif (
            $f =~ /\.gif$/
         or $f =~ /.png$/ 
         or $f =~ /.jpg$/ 
         or $f =~ /.ico$/
         or $f =~ /.svg$/
         or $f =~ /.svgz$/
         or $f =~ /.tgz$/
         or $f =~ /.css$/
         or $f =~ /.js$/
         or $f =~ /.htm$/
         or $f =~ /.html$/
        ) {

            push(@img_files, $full);

        } else {
            #-------------------------------------------------------------------
            #   Ignore non-header and non-source files such as README.md.            
            #-------------------------------------------------------------------
        }
    }
}

#-------------------------------------------------------------------------------
#@brief Add the given file to the file-queue if it hasn't already been added.
#       Function pulled from depends script and adapted for makepro.
#-------------------------------------------------------------------------------
sub queue
{
    my ($file) = @_;

    lock(%include);
    if (!defined($include{$file})) {
        $include{$file} = "";
        $file_queue->enqueue($file);
    }
}
